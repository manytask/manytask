{% extends "layout.html" %}
{% set active_page = "database" -%}

{% block content %}
    <link rel="stylesheet" href="{{ url_for('static', filename='css/database.css') }}">
    <div id="loader" class="position-absolute top-50 start-50">
        <div class="spinner-border text-secondary" style="width: 3rem; height: 3rem;"></div>
    </div>
    <div class="container-fluid position-relative">
        <div class="d-flex justify-content-between align-items-center mb-3">
            <h2 class="mb-0 d-flex align-items-center gap-2">
                Course Database
                <span id="db-stale-indicator"
                      class="db-stale-indicator d-none"
                      data-bs-toggle="tooltip"
                      data-bs-placement="left"
                      title="Data is outdated. Waiting to refresh…">
                    <i class="fas fa-triangle-exclamation"></i>
                </span>
            </h2>

            {% if is_course_admin %}
            <button id="toggle-personal-info" class="btn btn-outline-secondary btn-sm" title="Toggle personal info columns">
                <i class="fas fa-eye"></i> Toggle Personal Info
            </button>
            {% endif %}
        </div>

        <div class="db-search-controls mb-3 mt-4">

            <div class="db-search-group">
                <div class="db-search-input">
                    <input id="filter-value" type="text" class="form-control pr-1" placeholder="Search...">
                    <i class="fas fa-search db-search-icon"></i>
                </div>

                <button id="filter-clear" class="db-filter-clear btn btn-outline-secondary">
                    <i class="fas fa-times"></i> Clear
                </button>
            </div>
        </div>

        <div id="database-table" style="max-width: 800px; width: 100%; overflow-x: auto;"></div>

        {% if is_course_admin %}
            <div class="modal fade" id="editModal" tabindex="-1" aria-labelledby="editModalLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="editModalLabel">Edit Score</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <form id="editForm">
                                <div class="mb-3">
                                    <label class="form-label">Score</label>
                                    <input type="number" class="form-control" id="scoreInput">
                                </div>
                            </form>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            <button type="button" class="btn btn-primary" onclick="saveChanges()">Save changes</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="modal fade" id="editCommentModal" tabindex="-1" aria-labelledby="editCommentModalLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="editCommentModalLabel">Edit Comment</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <form id="editCommentForm">
                                <div class="mb-3">
                                    <label class="form-label">Comment for <span id="commentStudentName"></span></label>
                                    <textarea class="form-control" id="commentInput" rows="3" placeholder="Enter comment..."></textarea>
                                </div>
                            </form>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            <button type="button" class="btn btn-primary" onclick="saveComment()">Save comment</button>
                        </div>
                    </div>
                </div>
            </div>
        {% endif %}
    </div>

    <script src="https://cdn.jsdelivr.net/npm/tabulator-tables@5/dist/js/tabulator.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tabulator-tables@5/dist/css/tabulator.min.css" rel="stylesheet"
          id="light-theme">
    <link href="https://cdn.jsdelivr.net/npm/tabulator-tables@5/dist/css/tabulator_midnight.min.css" rel="stylesheet"
          id="dark-theme" disabled>


    <script>
        let currentEditCell = null;
        let editModal = null;
        let currentCommentCell = null;
        let editCommentModal = null;
        const mincolwidth = 30;

        class ScoresUpdater {
            constructor({table, snapshotUrl, updatesUrl, staleEl, debounceMs = 500}) {
                this.table = table;
                this.snapshotUrl = snapshotUrl;
                this.updatesUrl = updatesUrl;
                this.staleEl = staleEl;

                this.debounceMs = debounceMs;

                this.eventSource = null;
                this.dirty = false;

                this.pending = false;
                this.latestTimestamp = null;

                this.refreshTimer = null;
                this.refreshInFlight = false;
            }

            start() {
                if (!this.updatesUrl) return;
                if (this.eventSource) return;

                this.eventSource = new EventSource(this.updatesUrl);

                this.eventSource.addEventListener("init", (event) => {
                    this.latestTimestamp = event.data;
                });

                this.eventSource.addEventListener("update", (event) => {
                    this.latestTimestamp = event.data;
                    this.onRemoteUpdate();
                });

                this.eventSource.onerror = (e) => {
                    console.warn("SSE error:", e);
                    // Browser will auto-reconnect; keep stale indicator if we have pending updates.
                };
            }

            stop() {
                if (this.refreshTimer) {
                    clearTimeout(this.refreshTimer);
                    this.refreshTimer = null;
                }
                if (this.eventSource) {
                    this.eventSource.close();
                    this.eventSource = null;
                }
            }

            setDirty(value) {
                this.dirty = Boolean(value);

                if (!this.dirty && this.pending) {
                    // Apply queued update once editing finished.
                    this.scheduleRefresh();
                }
            }

            markStale(isStale) {
                if (!this.staleEl) return;
                if (isStale) {
                    this.staleEl.classList.remove("d-none");
                } else {
                    this.staleEl.classList.add("d-none");
                }
            }

            onRemoteUpdate() {
                if (this.dirty) {
                    this.pending = true;
                    this.markStale(true);
                    return;
                }
                this.scheduleRefresh();
            }

            scheduleRefresh() {
                if (this.refreshTimer) {
                    clearTimeout(this.refreshTimer);
                }
                this.refreshTimer = setTimeout(() => this.refreshNow(), this.debounceMs);
            }

            _captureState() {
                const tableHolder = document.querySelector("#database-table .tabulator-tableholder");
                const scrollTop = tableHolder ? tableHolder.scrollTop : 0;
                const scrollLeft = tableHolder ? tableHolder.scrollLeft : 0;

                const sorters = (this.table && typeof this.table.getSorters === "function")
                    ? this.table.getSorters().map(s => ({column: s.field, dir: s.dir}))
                    : [];

                const page = (this.table && typeof this.table.getPage === "function")
                    ? this.table.getPage()
                    : null;

                const pageSize = (this.table && typeof this.table.getPageSize === "function")
                    ? this.table.getPageSize()
                    : null;

                return {scrollTop, scrollLeft, sorters, page, pageSize};
            }

            _restoreState(state) {
                if (!state || !this.table) return;

                try {
                    if (state.pageSize && typeof this.table.setPageSize === "function") {
                        this.table.setPageSize(state.pageSize);
                    }
                    if (state.sorters && state.sorters.length && typeof this.table.setSort === "function") {
                        this.table.setSort(state.sorters);
                    }
                    if (state.page && typeof this.table.setPage === "function") {
                        this.table.setPage(state.page);
                    }
                } catch (e) {
                    console.warn("Failed to restore Tabulator state:", e);
                }

                // Restore scroll after DOM has a chance to render rows.
                setTimeout(() => {
                    const tableHolder = document.querySelector("#database-table .tabulator-tableholder");
                    if (tableHolder) {
                        tableHolder.scrollTop = state.scrollTop || 0;
                        tableHolder.scrollLeft = state.scrollLeft || 0;
                    }
                }, 0);
            }

            async refreshNow() {
                if (this.refreshInFlight) {
                    this.pending = true;
                    this.markStale(true);
                    return;
                }

                if (!this.table) return;

                if (this.dirty) {
                    this.pending = true;
                    this.markStale(true);
                    return;
                }

                this.refreshInFlight = true;

                const state = this._captureState();

                try {
                    const response = await fetch(this.snapshotUrl, {headers: {"Accept": "application/json"}});
                    if (!response.ok) {
                        throw new Error(`Snapshot fetch failed: ${response.status}`);
                    }
                    const data = await response.json();

                    // Keep columns/layout; only replace row data.
                    await this.table.replaceData(data.students);

                    this._restoreState(state);

                    this.pending = false;
                    this.markStale(false);
                } catch (e) {
                    console.error("Failed to refresh database table:", e);
                    this.pending = true;
                    this.markStale(true);
                } finally {
                    this.refreshInFlight = false;

                    if (this.pending && !this.dirty) {
                        this.scheduleRefresh();
                    }
                }
            }
        }

        window.scoresUpdater = null;

        function editCell(cell) {
            const readonlyFields = {{ readonly_fields|tojson }};
            if (readonlyFields.includes(cell.getField())) {
                return;
            }

            const isAdmin = {{ is_course_admin|tojson }};
            if (!isAdmin) {
                return;
            }

            if (window.scoresUpdater) {
                window.scoresUpdater.setDirty(true);
            }

            currentEditCell = cell;
            const value = cell.getValue() || 0;
            const scoreInput = document.getElementById('scoreInput');
            scoreInput.value = value;
            document.getElementById('editModalLabel').textContent = `Edit Score for ${cell.getColumn().getDefinition().title}`;
            editModal.show();

            // Immediately select input field after modal is shown
            editModal._element.addEventListener('shown.bs.modal', function () {
                scoreInput.select();
            }, {once: true});
        }

        function saveChanges() {
            if (!currentEditCell) return;

            const newScore = parseFloat(document.getElementById('scoreInput').value);
            if (isNaN(newScore)) {
                alert('Please enter a valid number');
                return;
            }

            const row = currentEditCell.getRow();
            const rowData = row.getData();
            const username = rowData.username;
            const taskName = currentEditCell.getColumn().getDefinition().field.split(".")[1];

            // Update database
            const newScores = {};
            newScores[taskName] = newScore;
            fetch('{{ url_for("api.update_database", course_name=course_name) }}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    row_data: rowData,
                    new_scores: newScores
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        row.update(data.row_data)
                        editModal.hide();
                    } else {
                        alert('Failed to update: ' + data.message);
                    }
                })
                .catch(error => {
                    console.error('Error updating entry:', error);
                    alert('Failed to update entry');
                });
        }

        function editComment(cell) {
            const isAdmin = {{ is_course_admin|tojson }};
            if (!isAdmin) {
                return;
            }

            if (window.scoresUpdater) {
                window.scoresUpdater.setDirty(true);
            }

            currentCommentCell = cell;
            const row = cell.getRow();
            const rowData = row.getData();
            const username = rowData.username;
            const currentComment = cell.getValue() || '';

            document.getElementById('commentStudentName').textContent = username;
            document.getElementById('commentInput').value = currentComment;
            editCommentModal.show();

            editCommentModal._element.addEventListener('shown.bs.modal', function () {
                document.getElementById('commentInput').focus();
            }, {once: true});
        }

        function saveComment() {
            if (!currentCommentCell) return;

            const newComment = document.getElementById('commentInput').value.trim();
            const row = currentCommentCell.getRow();
            const rowData = row.getData();
            const username = rowData.username;

            fetch('{{ url_for("api.update_comment", course_name=course_name) }}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    username: username,
                    comment: newComment || null
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        currentCommentCell.setValue(newComment || null);
                        editCommentModal.hide();
                    } else {
                        alert('Failed to update comment: ' + data.message);
                    }
                })
                .catch(error => {
                    console.error('Error updating comment:', error);
                    alert('Failed to update comment');
                });
        }
        function updateTheme() {
            const isDark = document.documentElement.getAttribute('data-bs-theme') === 'dark';

            const lightTheme = document.getElementById('light-theme');
            const darkTheme = document.getElementById('dark-theme');

            if (isDark) {
                lightTheme.disabled = true;
                darkTheme.disabled = false;
            } else {
                lightTheme.disabled = false;
                darkTheme.disabled = true;
            }

            if (window.tabulatorTable) {
                window.tabulatorTable.redraw(true);
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            {% if is_course_admin %}
                const editModalEl = document.getElementById('editModal');
                const editCommentModalEl = document.getElementById('editCommentModal');

                editModal = new bootstrap.Modal(editModalEl);
                editCommentModal = new bootstrap.Modal(editCommentModalEl);

                // Dirty flag: prevent live refresh from overwriting admin edits.
                editModalEl.addEventListener('shown.bs.modal', function () {
                    if (window.scoresUpdater) window.scoresUpdater.setDirty(true);
                });
                editModalEl.addEventListener('hidden.bs.modal', function () {
                    if (window.scoresUpdater) window.scoresUpdater.setDirty(false);
                });

                editCommentModalEl.addEventListener('shown.bs.modal', function () {
                    if (window.scoresUpdater) window.scoresUpdater.setDirty(true);
                });
                editCommentModalEl.addEventListener('hidden.bs.modal', function () {
                    if (window.scoresUpdater) window.scoresUpdater.setDirty(false);
                });

                document.getElementById('editForm').addEventListener('submit', function (e) {
                    e.preventDefault();
                    saveChanges();
                });

                document.getElementById('editCommentForm').addEventListener('submit', function (e) {
                    e.preventDefault();
                    saveComment();
                });
            {% endif %}

            // Watch theme changes for database viewer
            updateTheme();
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.attributeName === 'data-bs-theme') {
                        updateTheme();
                    }
                });
            });
            observer.observe(document.documentElement, {
                attributes: true,
                attributeFilter: ['data-bs-theme']
            });


            const valueEl = document.getElementById("filter-value");

            function customFilter(data) {
                const searchTerm = valueEl.value.toLowerCase();
                if (data.username.toLowerCase().includes(searchTerm)) {
                    return true;
                }
                if (data.first_name && data.last_name) {
                    const full_name = `${data.first_name} ${data.last_name}`.toLowerCase();
                    return full_name.includes(searchTerm);
                }
                return false;
            }

            document.getElementById("filter-value")
                .addEventListener("keyup", function () {
                    window.tabulatorTable.setFilter(customFilter);
                });

            document.addEventListener('keydown', function (event) {
                if ((event.ctrlKey || event.metaKey) && event.key === 'f') {
                    event.preventDefault();
                    document.getElementById('filter-value').focus();
                }
            });

            document.getElementById("filter-clear").addEventListener('click', function (event) {
                valueEl.value = "";
                window.tabulatorTable.clearFilter();
            })

            fetch('{{ url_for("api.get_database", course_name=course_name) }}')
                .then(response => response.json())
                .then(data => {
                    let columns = [
                        {
                            title: "Username",
                            field: "username",
                            frozen: true,
                            minWidth: 1,
                            width: 120,
                            headerTooltip: "Username",
                            formatter: function(cell) {
                                const value = cell.getValue();
                                const rowData = cell.getRow().getData();
                                {% if is_course_admin %}
                                if (rowData && rowData.repo_url) {
                                    const url = rowData.repo_url;
                                    return `<a href="${url}" target="_blank" rel="noopener noreferrer">${value}</a>`;
                                }
                                {% endif %}
                                return value;
                            }
                        },
                        {% if is_course_admin %}
                        {
                            title: "First<br>Name",
                            field: "first_name",
                            frozen: true,
                            minWidth: 1,
                            headerTooltip: "First Name"
                        },
                        {
                            title: "Last<br>Name",
                            field: "last_name",
                            frozen: true,
                            minWidth: 1,
                            headerTooltip: "Last Name"
                        },
                        {% endif %}
                        {
                            title: "Grade",
                            field: "grade",
                            frozen: true,
                            sorter: "number",
                            hozAlign: "center",
                            minWidth: 1,
                            with: 200,
                            headerTooltip: "Course grade"
                        },
                        {
                            title: "Total<br>Score",
                            field: "total_score",
                            frozen: true,
                            sorter: "number",
                            hozAlign: "center",
                            minWidth: 1,
                            headerTooltip: "Total Score"
                        },
                        {
                            title: "Per<br>cent",
                            field: "percent",
                            frozen: true,
                            sorter: "number",
                            hozAlign: "center",
                            minWidth: 1,
                            headerTooltip: "% completed",
                            formatter: function (cell, formatterParams, onRendered) {
                                return cell.getValue().toFixed(1);
                            }
                        },
                        {
                            title: "LHW",
                            field: "large_count",
                            frozen: true,
                            sorter: "number",
                            hozAlign: "center",
                            minWidth: 1,
                            headerTooltip: "Number of Large Homeworks"
                        },
                        {
                            title: "Bonus",
                            field: "scores.bonus_score",
                            frozen: true,
                            sorter: "number",
                            hozAlign: "center",
                            minWidth: 1,
                            headerTooltip: "Bonus scores",
                            cellClick: function (e, cell) {
                                editCell(cell);
                            },
                        }
                    ];

                    // Add comment column only for course admins
                    {% if is_course_admin %}
                    columns.push({
                        title: "Comment",
                        field: "comment",
                        frozen: true,
                        minWidth: 1,
                        width: 200,
                        headerTooltip: "Admin comment (click to edit)",
                        cellClick: function (e, cell) {
                            editComment(cell);
                        },
                        formatter: function(cell) {
                            const value = cell.getValue();
                            return value ? value : '<em style="color: #999;">No comment</em>';
                        }
                    });
                    {% endif %}

                    if (window.innerWidth < 500) {
                        columns[1].width = 60;
                    }

                    const taskGroups = {};

                    data.tasks.forEach(task => {
                        const groupName = task.group || 'ungrouped';
                        if (!taskGroups[groupName]) {
                            taskGroups[groupName] = [];
                        }
                        taskGroups[groupName].push(task);
                    });

                    Object.entries(taskGroups).forEach(([groupName, tasks]) => {
                        // Mini-columns for each task
                        const groupColumns = tasks.map(task => ({
                            title: task.name,
                            field: `scores.${task.name}`,
                            sorter: "number",
                            hozAlign: "center",
                            headerTooltip: task.name,
                            {% if is_course_admin %}
                                cellClick: function (e, cell) {
                                    editCell(cell);
                                },
                            {% endif %}
                        }));

                        // Add grouped columns
                        columns.push({
                            title: `${groupName} ▼`,
                            columns: groupColumns,
                            headerClick: function (e, column) {
                                const table = column.getTable();
                                const allCols = column.getSubColumns();

                                // Create collapsed column definition
                                const collapsedColumnDef = {
                                    title: `${groupName} ►`,
                                    field: `${groupName}_collapsed`,
                                    width: 120,
                                    headerSort: false,
                                    visible: false,
                                    headerClick: function (e, col) {
                                        // Show all columns in the group and hide the collapsed column
                                        allCols.forEach(subcol => subcol.show());
                                        col.hide();
                                        table.redraw(true);
                                    },
                                    formatter: function (cell) {
                                        let sum = 0;
                                        const rowData = cell.getRow().getData();
                                        allCols.forEach(col => {
                                            const field = col.getField();
                                            const value = field.split('.').reduce((obj, key) => obj && obj[key], rowData);
                                            if (value) sum += value;
                                        });
                                        // Store the sum in the row data
                                        const newData = {};
                                        newData[cell.getField()] = sum;
                                        cell.getRow().update(newData);
                                        return sum;
                                    }
                                };

                                // Add collapsed column if it doesn't exist
                                let collapsedCol = table.getColumn(`${groupName}_collapsed`);
                                if (!collapsedCol) {
                                    // Find the index where this group's columns start
                                    const firstColInGroup = allCols[0];
                                    table.addColumn(collapsedColumnDef, true, firstColInGroup);
                                    collapsedCol = table.getColumn(`${groupName}_collapsed`);
                                }
                                // Hide all columns in the group and show the collapsed column
                                allCols.forEach(col => col.hide());
                                collapsedCol.show();

                                table.redraw(true);
                            }
                        });
                    });

                    window.tabulatorTable = new Tabulator("#database-table", {
                        data: data.students,
                        columns: columns,
                        layout: "fitDataTable",
                        height: "70vh",
                        pagination: true,
                        paginationSize: 100,
                        paginationSizeSelector: [25, 50, 100, 200, true],
                        initialSort: [{column: "total_score", dir: "desc"}],
                        groupBy: false,
                        downloadConfig: {
                            columnHeaders: true,
                            columnGroups: false,
                            rowGroups: false,
                            columnOutput: function (column) {

                                return column.getField();
                            },
                            dataOutput: function (value, column, row, rowData) {


                                if (column.getField().endsWith('_collapsed')) {
                                    const groupName = column.getField().replace('_collapsed', '');
                                    const groupCol = window.tabulatorTable.getColumns().find(col =>
                                        col.getDefinition().title.replace(' ▼', '') === groupName
                                    );

                                    if (groupCol && groupCol.getSubColumns) {
                                        const subCols = groupCol.getSubColumns();
                                        let sum = 0;

                                        subCols.forEach(col => {
                                            const field = col.getField();
                                            const taskName = field.split('.')[1];
                                            const taskValue = rowData.scores && rowData.scores[taskName] || 0;
                                            sum += taskValue;
                                        });


                                        return sum.toFixed(1);
                                    }
                                }

                                return value;
                            }
                        },
                        rowFormatter: function (row) {

                            const data = row.getData();

                            // Add individual task scores and group totals
                            const groupColumns = window.tabulatorTable.getColumns().filter(col => col.getDefinition().columns);
                            groupColumns.forEach(groupCol => {
                                const subCols = groupCol.getSubColumns();
                                const groupName = groupCol.getDefinition().title.replace(' ▼', '');


                                if (subCols && subCols.length > 0) {
                                    let sum = 0;
                                    const collapsedCol = window.tabulatorTable.getColumn(`${groupName}_collapsed`);
                                    const isCollapsed = collapsedCol && collapsedCol.isVisible();


                                    subCols.forEach(col => {
                                        const field = col.getField();
                                        const taskName = field.split('.')[1];
                                        const value = data.scores && data.scores[taskName] || 0;

                                        if (value) sum += value;
                                    });

                                    if (isCollapsed && collapsedCol) {

                                        const cell = row.getCell(`${groupName}_collapsed`);
                                        if (cell) {
                                            cell.setValue(sum.toFixed(1));
                                        }
                                    }
                                }
                            });
                        },
                        columnDefaults: {
                            resizable: true,
                            minWidth: mincolwidth,
                            maxWidth: 300,
                            headerMinWidth: mincolwidth,
                            formatter: "plaintext",
                            formatterParams: {
                                textLimit: false,
                                htmlChars: true
                            },
                            cssClass: "text-wrap",
                            tooltip: function (cell) {
                                if (!cell || typeof cell.getField !== 'function') return "";
                                try {
                                    const isAdmin = {{ is_course_admin|tojson }};
                                    const field = cell.getField();
                                    if (!isAdmin && field !== "username" && field !== "total_score") {
                                        return "Only course admins can edit scores";
                                    }
                                    const value = cell.getValue();
                                    return value !== undefined && value !== null ? value.toString() : "";
                                } catch (e) {

                                    return "";
                                }
                            },
                            vertAlign: "middle"
                        },
                        persistenceMode: "local",
                        persistentLayout: true
                    });

                    window.tabulatorTable.on("tableBuilt", function () {
                        document.getElementById("loader").style.display = "none";

                        // Tooltip for stale-indicator.
                        const staleEl = document.getElementById("db-stale-indicator");
                        if (staleEl) {
                            try {
                                new bootstrap.Tooltip(staleEl);
                            } catch (e) {
                                console.warn("Failed to init tooltip:", e);
                            }
                        }

                        // Live updates via SSE.
                        const updatesUrl = '{{ url_for("api.database_updates", course_name=course_name) }}';
                        const snapshotUrl = '{{ url_for("api.get_database", course_name=course_name) }}';

                        window.scoresUpdater = new ScoresUpdater({
                            table: window.tabulatorTable,
                            snapshotUrl,
                            updatesUrl,
                            staleEl,
                            debounceMs: 500,
                        });
                        window.scoresUpdater.start();

                        window.addEventListener("beforeunload", () => {
                            if (window.scoresUpdater) window.scoresUpdater.stop();
                        });
                    });

                    // Wait for a short delay to ensure table is rendered
                    setTimeout(() => {
                        const footer = document.querySelector(".tabulator-footer .tabulator-paginator");
                        if (footer) {
                            const exportButton = document.createElement("button");
                            exportButton.id = "export-csv";
                            exportButton.style.marginRight = "10px";
                            exportButton.textContent = "Export as CSV";

                            exportButton.onclick = function () {

                                if (!window.tabulatorTable) {
                                    console.error('Tabulator instance not found!');
                                    return;
                                }


                                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                                const courseName = "{{ course_name }}".replace(/[^a-zA-Z0-9]/g, '_');

                                try {

                                    const table = window.tabulatorTable;

                                    // Get current data with all calculated values
                                    const currentData = table.getData();


                                    // Get visible columns
                                    const visibleColumns = table.getColumns()
                                        .filter(col => col.isVisible())
                                        .map(col => col.getField());


                                    // Prepare data for export
                                    const exportData = currentData.map(row => {
                                        const exportRow = {};
                                        visibleColumns.forEach(field => {
                                            if (field.endsWith('_collapsed')) {

                                                const groupName = field.replace('_collapsed', '');
                                                const groupCol = table.getColumn(field);
                                                if (groupCol) {
                                                    const cell = groupCol.getCells().find(c =>
                                                        c.getRow().getData().username === row.username
                                                    );
                                                    if (cell) {
                                                        exportRow[field] = parseInt(cell.getValue()) || 0;

                                                    }
                                                }
                                            } else if (field.startsWith('scores.')) {
                                                // Handle nested scores data

                                                const taskName = field.split('.')[1];
                                                const value = row.scores && row.scores[taskName] || 0;
                                                exportRow[field] = value;

                                            } else {
                                                exportRow[field] = row[field];
                                            }
                                        });

                                        return exportRow;
                                    });


                                    // Create CSV content
                                    const headers = visibleColumns;
                                    const csv = [
                                        headers.join(','),
                                        ...exportData.map(row =>
                                            headers.map(field =>
                                                JSON.stringify(row[field] || '')
                                            ).join(',')
                                        )
                                    ].join('\n');

                                    // Trigger download
                                    const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
                                    const link = document.createElement('a');
                                    if (link.download !== undefined) {
                                        const url = URL.createObjectURL(blob);
                                        link.setAttribute('href', url);
                                        link.setAttribute('download', `${courseName}_database_export_${timestamp}.csv`);
                                        link.style.visibility = 'hidden';
                                        document.body.appendChild(link);
                                        link.click();
                                        document.body.removeChild(link);
                                    }
                                } catch (error) {
                                    console.error('Error exporting CSV:', error);
                                }
                            };

                            footer.insertBefore(exportButton, footer.firstChild);
                        }
                    }, 100);
                    // Toggle personal info columns (admins only)
                    {% if is_course_admin %}
                    const toggleButton = document.getElementById('toggle-personal-info');
                    if (toggleButton) {
                        const personalColumns = ['first_name', 'last_name', 'comment'];

                        toggleButton.addEventListener('click', function() {
                            const firstCol = window.tabulatorTable.getColumn('first_name');
                            const isVisible = firstCol ? firstCol.isVisible() : false;
                            
                            personalColumns.forEach(field => {
                                const col = window.tabulatorTable.getColumn(field);
                                if (col) {
                                    if (isVisible) {
                                        col.hide();
                                    } else {
                                        col.show();
                                    }
                                }
                            });
                            
                            const icon = toggleButton.querySelector('i');
                            if (icon) {
                                if (isVisible) {
                                    icon.classList.remove('fa-eye');
                                    icon.classList.add('fa-eye-slash');
                                } else {
                                    icon.classList.remove('fa-eye-slash');
                                    icon.classList.add('fa-eye');
                                }
                            }
                            
                            window.tabulatorTable.redraw(true);
                        });
                    }
                    {% endif %}
                })
                .catch(error => {
                    console.error('Error creating table:', error);
                });
        });
    </script>
{% endblock %}
