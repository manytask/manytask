{% extends "layout.html" %}
{% set active_page = "database" -%}

{% block content %}
    <link rel="stylesheet" href="{{ url_for('static', filename='css/database.css') }}">
    <div id="loader" class="position-absolute top-50 start-50">
        <div class="spinner-border text-secondary" style="width: 3rem; height: 3rem;"></div>
    </div>
    <div class="container-fluid position-relative">
        <div class="d-flex justify-content-between align-items-center mb-3">
            <h2 class="mb-0">Course Database</h2>
            
            {% if is_course_admin %}
            <button id="toggle-personal-info" class="btn btn-outline-secondary btn-sm" title="Toggle personal info columns">
                <i class="fas fa-eye"></i> Toggle Personal Info
            </button>
            {% endif %}
        </div>

        <div class="db-search-controls mb-3 mt-4">

            <div class="db-search-group">
                <div class="db-search-input">
                    <input id="filter-value" type="text" class="form-control pr-1" placeholder="Search...">
                    <i class="fas fa-search db-search-icon"></i>
                </div>

                <button id="filter-clear" class="db-filter-clear btn btn-outline-secondary">
                    <i class="fas fa-times"></i> Clear
                </button>
            </div>
        </div>

        <div id="database-table" style="max-width: 800px; width: 100%; overflow-x: auto;"></div>

        {% if is_course_admin %}
            <div class="modal fade" id="editModal" tabindex="-1" aria-labelledby="editModalLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="editModalLabel">Edit Score</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <form id="editForm">
                                <div class="mb-3">
                                    <label class="form-label">Score</label>
                                    <input type="number" class="form-control" id="scoreInput">
                                </div>
                            </form>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            <button type="button" class="btn btn-primary" onclick="saveChanges()">Save changes</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="modal fade" id="editCommentModal" tabindex="-1" aria-labelledby="editCommentModalLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="editCommentModalLabel">Edit Comment</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <form id="editCommentForm">
                                <div class="mb-3">
                                    <label class="form-label">Comment for <span id="commentStudentName"></span></label>
                                    <textarea class="form-control" id="commentInput" rows="3" placeholder="Enter comment..."></textarea>
                                </div>
                            </form>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            <button type="button" class="btn btn-primary" onclick="saveComment()">Save comment</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="modal fade" id="editGradeModal" tabindex="-1" aria-labelledby="editGradeModalLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="editGradeModalLabel">Редактировать оценку</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <form id="editGradeForm">
                                <div class="mb-3">
                                    <label class="form-label">Студент: <strong><span id="gradeStudentName"></span></strong></label>
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Текущая оценка: <span id="currentGradeValue"></span> <span id="gradeOverrideBadge" class="badge bg-warning" style="display: none;">Установлено вручную</span></label>
                                </div>
                                <div class="mb-3">
                                    <label for="gradeInput" class="form-label">Новая оценка (2-5)</label>
                                    <input type="number" class="form-control" id="gradeInput" min="2" max="5" step="1" required>
                                    <div class="form-text">Введите оценку от 2 до 5</div>
                                </div>
                                <div class="mb-3" id="clearOverrideContainer" style="display: none;">
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="clearOverrideBtn">
                                        Сбросить переопределение (вернуть автоматический расчет)
                                    </button>
                                </div>
                            </form>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
                            <button type="button" class="btn btn-primary" onclick="saveGrade()">Сохранить</button>
                        </div>
                    </div>
                </div>
            </div>
        {% endif %}
    </div>

    <script src="https://cdn.jsdelivr.net/npm/tabulator-tables@5/dist/js/tabulator.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tabulator-tables@5/dist/css/tabulator.min.css" rel="stylesheet"
          id="light-theme">
    <link href="https://cdn.jsdelivr.net/npm/tabulator-tables@5/dist/css/tabulator_midnight.min.css" rel="stylesheet"
          id="dark-theme" disabled>


    <script>
        let currentEditCell = null;
        let editModal = null;
        let currentCommentCell = null;
        let editCommentModal = null;
        let currentGradeCell = null;
        let editGradeModal = null;
        const mincolwidth = 30;

        function editCell(cell) {
            const readonlyFields = {{ readonly_fields|tojson }};
            if (readonlyFields.includes(cell.getField())) {
                return;
            }

            const isAdmin = {{ is_course_admin|tojson }};
            if (!isAdmin) {
                return;
            }

            currentEditCell = cell;
            const value = cell.getValue() || 0;
            const scoreInput = document.getElementById('scoreInput');
            scoreInput.value = value;
            document.getElementById('editModalLabel').textContent = `Edit Score for ${cell.getColumn().getDefinition().title}`;
            editModal.show();

            // Immediately select input field after modal is shown
            editModal._element.addEventListener('shown.bs.modal', function () {
                scoreInput.select();
            }, {once: true});
        }

        function saveChanges() {
            if (!currentEditCell) return;

            const newScore = parseFloat(document.getElementById('scoreInput').value);
            if (isNaN(newScore)) {
                alert('Please enter a valid number');
                return;
            }

            const row = currentEditCell.getRow();
            const rowData = row.getData();
            const username = rowData.username;
            const taskName = currentEditCell.getColumn().getDefinition().field.split(".")[1];

            // Update database
            const newScores = {};
            newScores[taskName] = newScore;
            fetch('{{ url_for("api.update_database", course_name=course_name) }}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    row_data: rowData,
                    new_scores: newScores
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        row.update(data.row_data)
                        editModal.hide();
                    } else {
                        alert('Failed to update: ' + data.message);
                    }
                })
                .catch(error => {
                    console.error('Error updating entry:', error);
                    alert('Failed to update entry');
                });
        }

        function editComment(cell) {
            const isAdmin = {{ is_course_admin|tojson }};
            if (!isAdmin) {
                return;
            }

            currentCommentCell = cell;
            const row = cell.getRow();
            const rowData = row.getData();
            const username = rowData.username;
            const currentComment = cell.getValue() || '';

            document.getElementById('commentStudentName').textContent = username;
            document.getElementById('commentInput').value = currentComment;
            editCommentModal.show();

            editCommentModal._element.addEventListener('shown.bs.modal', function () {
                document.getElementById('commentInput').focus();
            }, {once: true});
        }

        function saveComment() {
            if (!currentCommentCell) return;

            const newComment = document.getElementById('commentInput').value.trim();
            const row = currentCommentCell.getRow();
            const rowData = row.getData();
            const username = rowData.username;

            fetch('{{ url_for("api.update_comment", course_name=course_name) }}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    username: username,
                    comment: newComment || null
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        currentCommentCell.setValue(newComment || null);
                        editCommentModal.hide();
                    } else {
                        alert('Failed to update comment: ' + data.message);
                    }
                })
                .catch(error => {
                    console.error('Error updating comment:', error);
                    alert('Failed to update comment');
                });
        }

        // Helper function to reload table data from server
        function reloadTableData() {
            return fetch('{{ url_for("api.get_database", course_name=course_name) }}')
                .then(response => response.json())
                .then(data => {
                    window.tabulatorTable.setData(data.students);
                });
        }

        function editGrade(cell) {
            const isAdmin = {{ is_course_admin|tojson }};
            if (!isAdmin) {
                return;
            }

            currentGradeCell = cell;
            const row = cell.getRow();
            const rowData = row.getData();
            const username = rowData.username;
            const currentGrade = cell.getValue() || 0;
            const isOverride = rowData.grade_is_override || false;

            document.getElementById('gradeStudentName').textContent = username;
            document.getElementById('currentGradeValue').textContent = currentGrade;
            document.getElementById('gradeInput').value = currentGrade;

            // Show/hide override badge
            const badge = document.getElementById('gradeOverrideBadge');
            const clearContainer = document.getElementById('clearOverrideContainer');
            if (isOverride) {
                badge.style.display = 'inline';
                clearContainer.style.display = 'block';
            } else {
                badge.style.display = 'none';
                clearContainer.style.display = 'none';
            }

            editGradeModal.show();

            // Focus on input after modal is shown
            editGradeModal._element.addEventListener('shown.bs.modal', function () {
                document.getElementById('gradeInput').select();
            }, {once: true});

            // Setup clear override button handler
            document.getElementById('clearOverrideBtn').onclick = function() {
                if (!confirm('Сбросить ручное переопределение оценки? Оценка будет автоматически пересчитана.')) {
                    return;
                }

                fetch('{{ url_for("api.clear_grade_override", course_name=course_name) }}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        username: username
                    })
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Reload table to show recalculated grade without override
                            reloadTableData().then(() => {
                                editGradeModal.hide();
                            });
                        } else {
                            alert('Не удалось сбросить переопределение: ' + data.message);
                        }
                    })
                    .catch(error => {
                        console.error('Error clearing grade override:', error);
                        alert('Не удалось сбросить переопределение');
                    });
            };
        }

        function saveGrade() {
            if (!currentGradeCell) return;

            const newGrade = parseInt(document.getElementById('gradeInput').value);
            if (isNaN(newGrade) || newGrade < 2 || newGrade > 5) {
                alert('Пожалуйста, введите корректную оценку от 2 до 5');
                return;
            }

            const row = currentGradeCell.getRow();
            const rowData = row.getData();
            const username = rowData.username;

            fetch('{{ url_for("api.override_grade", course_name=course_name) }}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    username: username,
                    grade: newGrade
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Reload table to show updated grade with override indicator (yellow background + asterisk)
                        reloadTableData().then(() => {
                            editGradeModal.hide();
                        });
                    } else {
                        alert('Не удалось обновить оценку: ' + data.message);
                    }
                })
                .catch(error => {
                    console.error('Error updating grade:', error);
                    alert('Не удалось обновить оценку');
                });
        }

        function updateTheme() {
            const isDark = document.documentElement.getAttribute('data-bs-theme') === 'dark';

            const lightTheme = document.getElementById('light-theme');
            const darkTheme = document.getElementById('dark-theme');

            if (isDark) {
                lightTheme.disabled = true;
                darkTheme.disabled = false;
            } else {
                lightTheme.disabled = false;
                darkTheme.disabled = true;
            }

            if (window.tabulatorTable) {
                window.tabulatorTable.redraw(true);
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            {% if is_course_admin %}
                editModal = new bootstrap.Modal(document.getElementById('editModal'));
                editCommentModal = new bootstrap.Modal(document.getElementById('editCommentModal'));
                editGradeModal = new bootstrap.Modal(document.getElementById('editGradeModal'));

                document.getElementById('editForm').addEventListener('submit', function (e) {
                    e.preventDefault();
                    saveChanges();
                });

                document.getElementById('editCommentForm').addEventListener('submit', function (e) {
                    e.preventDefault();
                    saveComment();
                });

                document.getElementById('editGradeForm').addEventListener('submit', function (e) {
                    e.preventDefault();
                    saveGrade();
                });
            {% endif %}

            // Watch theme changes for database viewer
            updateTheme();
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.attributeName === 'data-bs-theme') {
                        updateTheme();
                    }
                });
            });
            observer.observe(document.documentElement, {
                attributes: true,
                attributeFilter: ['data-bs-theme']
            });


            const valueEl = document.getElementById("filter-value");

            function customFilter(data) {
                const searchTerm = valueEl.value.toLowerCase();
                if (data.username.toLowerCase().includes(searchTerm)) {
                    return true;
                }
                if (data.first_name && data.last_name) {
                    const full_name = `${data.first_name} ${data.last_name}`.toLowerCase();
                    return full_name.includes(searchTerm);
                }
                return false;
            }

            document.getElementById("filter-value")
                .addEventListener("keyup", function () {
                    window.tabulatorTable.setFilter(customFilter);
                });

            document.addEventListener('keydown', function (event) {
                if ((event.ctrlKey || event.metaKey) && event.key === 'f') {
                    event.preventDefault();
                    document.getElementById('filter-value').focus();
                }
            });

            document.getElementById("filter-clear").addEventListener('click', function (event) {
                valueEl.value = "";
                window.tabulatorTable.clearFilter();
            })

            fetch('{{ url_for("api.get_database", course_name=course_name) }}')
                .then(response => response.json())
                .then(data => {
                    let columns = [
                        {
                            title: "Username",
                            field: "username",
                            frozen: true,
                            minWidth: 1,
                            width: 120,
                            headerTooltip: "Username",
                            formatter: function(cell) {
                                const value = cell.getValue();
                                const rowData = cell.getRow().getData();
                                {% if is_course_admin %}
                                if (rowData && rowData.repo_url) {
                                    const url = rowData.repo_url;
                                    return `<a href="${url}" target="_blank" rel="noopener noreferrer">${value}</a>`;
                                }
                                {% endif %}
                                return value;
                            }
                        },
                        {% if is_course_admin %}
                        {
                            title: "First<br>Name",
                            field: "first_name",
                            frozen: true,
                            minWidth: 1,
                            headerTooltip: "First Name"
                        },
                        {
                            title: "Last<br>Name",
                            field: "last_name",
                            frozen: true,
                            minWidth: 1,
                            headerTooltip: "Last Name"
                        },
                        {% endif %}
                        {
                            title: "Grade",
                            field: "grade",
                            frozen: true,
                            sorter: "number",
                            hozAlign: "center",
                            minWidth: 1,
                            with: 200,
                            headerTooltip: "Course grade",
                            formatter: function (cell, formatterParams, onRendered) {
                                const row = cell.getRow().getData();
                                const grade = cell.getValue();
                                const isOverride = row.grade_is_override || false;

                                // Apply visual styling for override grades
                                if (isOverride) {
                                    const cellElement = cell.getElement();
                                    cellElement.classList.add('grade-override-cell');
                                    cellElement.title = "Оценка установлена вручную администратором";
                                    {% if is_course_admin %}
                                    cellElement.classList.add('grade-cell-clickable');
                                    {% endif %}
                                    return grade + " *";
                                } else {
                                    {% if is_course_admin %}
                                    cell.getElement().classList.add('grade-cell-clickable');
                                    {% endif %}
                                    return grade;
                                }
                            },
                            {% if is_course_admin %}
                            cellClick: function (e, cell) {
                                editGrade(cell);
                            },
                            {% endif %}
                        },
                        {
                            title: "Total<br>Score",
                            field: "total_score",
                            frozen: true,
                            sorter: "number",
                            hozAlign: "center",
                            minWidth: 1,
                            headerTooltip: "Total Score"
                        },
                        {
                            title: "Per<br>cent",
                            field: "percent",
                            frozen: true,
                            sorter: "number",
                            hozAlign: "center",
                            minWidth: 1,
                            headerTooltip: "% completed",
                            formatter: function (cell, formatterParams, onRendered) {
                                return cell.getValue().toFixed(1);
                            }
                        },
                        {
                            title: "LHW",
                            field: "large_count",
                            frozen: true,
                            sorter: "number",
                            hozAlign: "center",
                            minWidth: 1,
                            headerTooltip: "Number of Large Homeworks"
                        },
                        {
                            title: "Bonus",
                            field: "scores.bonus_score",
                            frozen: true,
                            sorter: "number",
                            hozAlign: "center",
                            minWidth: 1,
                            headerTooltip: "Bonus scores",
                            cellClick: function (e, cell) {
                                editCell(cell);
                            },
                        }
                    ];

                    // Add comment column only for course admins
                    {% if is_course_admin %}
                    columns.push({
                        title: "Comment",
                        field: "comment",
                        frozen: true,
                        minWidth: 1,
                        width: 200,
                        headerTooltip: "Admin comment (click to edit)",
                        cellClick: function (e, cell) {
                            editComment(cell);
                        },
                        formatter: function(cell) {
                            const value = cell.getValue();
                            return value ? value : '<em style="color: #999;">No comment</em>';
                        }
                    });
                    {% endif %}

                    if (window.innerWidth < 500) {
                        columns[1].width = 60;
                    }

                    const taskGroups = {};

                    data.tasks.forEach(task => {
                        const groupName = task.group || 'ungrouped';
                        if (!taskGroups[groupName]) {
                            taskGroups[groupName] = [];
                        }
                        taskGroups[groupName].push(task);
                    });

                    Object.entries(taskGroups).forEach(([groupName, tasks]) => {
                        // Mini-columns for each task
                        const groupColumns = tasks.map(task => ({
                            title: task.name,
                            field: `scores.${task.name}`,
                            sorter: "number",
                            hozAlign: "center",
                            headerTooltip: task.name,
                            {% if is_course_admin %}
                                cellClick: function (e, cell) {
                                    editCell(cell);
                                },
                            {% endif %}
                        }));

                        // Add grouped columns
                        columns.push({
                            title: `${groupName} ▼`,
                            columns: groupColumns,
                            headerClick: function (e, column) {
                                const table = column.getTable();
                                const allCols = column.getSubColumns();

                                // Create collapsed column definition
                                const collapsedColumnDef = {
                                    title: `${groupName} ►`,
                                    field: `${groupName}_collapsed`,
                                    width: 120,
                                    headerSort: false,
                                    visible: false,
                                    headerClick: function (e, col) {
                                        // Show all columns in the group and hide the collapsed column
                                        allCols.forEach(subcol => subcol.show());
                                        col.hide();
                                        table.redraw(true);
                                    },
                                    formatter: function (cell) {
                                        let sum = 0;
                                        const rowData = cell.getRow().getData();
                                        allCols.forEach(col => {
                                            const field = col.getField();
                                            const value = field.split('.').reduce((obj, key) => obj && obj[key], rowData);
                                            if (value) sum += value;
                                        });
                                        // Store the sum in the row data
                                        const newData = {};
                                        newData[cell.getField()] = sum;
                                        cell.getRow().update(newData);
                                        return sum;
                                    }
                                };

                                // Add collapsed column if it doesn't exist
                                let collapsedCol = table.getColumn(`${groupName}_collapsed`);
                                if (!collapsedCol) {
                                    // Find the index where this group's columns start
                                    const firstColInGroup = allCols[0];
                                    table.addColumn(collapsedColumnDef, true, firstColInGroup);
                                    collapsedCol = table.getColumn(`${groupName}_collapsed`);
                                }
                                // Hide all columns in the group and show the collapsed column
                                allCols.forEach(col => col.hide());
                                collapsedCol.show();

                                table.redraw(true);
                            }
                        });
                    });

                    window.tabulatorTable = new Tabulator("#database-table", {
                        data: data.students,
                        columns: columns,
                        layout: "fitDataTable",
                        height: "70vh",
                        pagination: true,
                        paginationSize: 100,
                        paginationSizeSelector: [25, 50, 100, 200, true],
                        initialSort: [{column: "total_score", dir: "desc"}],
                        groupBy: false,
                        downloadConfig: {
                            columnHeaders: true,
                            columnGroups: false,
                            rowGroups: false,
                            columnOutput: function (column) {

                                return column.getField();
                            },
                            dataOutput: function (value, column, row, rowData) {


                                if (column.getField().endsWith('_collapsed')) {
                                    const groupName = column.getField().replace('_collapsed', '');
                                    const groupCol = window.tabulatorTable.getColumns().find(col =>
                                        col.getDefinition().title.replace(' ▼', '') === groupName
                                    );

                                    if (groupCol && groupCol.getSubColumns) {
                                        const subCols = groupCol.getSubColumns();
                                        let sum = 0;

                                        subCols.forEach(col => {
                                            const field = col.getField();
                                            const taskName = field.split('.')[1];
                                            const taskValue = rowData.scores && rowData.scores[taskName] || 0;
                                            sum += taskValue;
                                        });


                                        return sum.toFixed(1);
                                    }
                                }

                                return value;
                            }
                        },
                        rowFormatter: function (row) {

                            const data = row.getData();

                            // Add individual task scores and group totals
                            const groupColumns = window.tabulatorTable.getColumns().filter(col => col.getDefinition().columns);
                            groupColumns.forEach(groupCol => {
                                const subCols = groupCol.getSubColumns();
                                const groupName = groupCol.getDefinition().title.replace(' ▼', '');


                                if (subCols && subCols.length > 0) {
                                    let sum = 0;
                                    const collapsedCol = window.tabulatorTable.getColumn(`${groupName}_collapsed`);
                                    const isCollapsed = collapsedCol && collapsedCol.isVisible();


                                    subCols.forEach(col => {
                                        const field = col.getField();
                                        const taskName = field.split('.')[1];
                                        const value = data.scores && data.scores[taskName] || 0;

                                        if (value) sum += value;
                                    });

                                    if (isCollapsed && collapsedCol) {

                                        const cell = row.getCell(`${groupName}_collapsed`);
                                        if (cell) {
                                            cell.setValue(sum.toFixed(1));
                                        }
                                    }
                                }
                            });
                        },
                        columnDefaults: {
                            resizable: true,
                            minWidth: mincolwidth,
                            maxWidth: 300,
                            headerMinWidth: mincolwidth,
                            formatter: "plaintext",
                            formatterParams: {
                                textLimit: false,
                                htmlChars: true
                            },
                            cssClass: "text-wrap",
                            tooltip: function (cell) {
                                if (!cell || typeof cell.getField !== 'function') return "";
                                try {
                                    const isAdmin = {{ is_course_admin|tojson }};
                                    const field = cell.getField();
                                    if (!isAdmin && field !== "username" && field !== "total_score") {
                                        return "Only course admins can edit scores";
                                    }
                                    const value = cell.getValue();
                                    return value !== undefined && value !== null ? value.toString() : "";
                                } catch (e) {

                                    return "";
                                }
                            },
                            vertAlign: "middle"
                        },
                        persistenceMode: "local",
                        persistentLayout: true
                    });

                    window.tabulatorTable.on("tableBuilt", function () {
                        document.getElementById("loader").style.display = "none"
                    });

                    // Wait for a short delay to ensure table is rendered
                    setTimeout(() => {
                        const footer = document.querySelector(".tabulator-footer .tabulator-paginator");
                        if (footer) {
                            const exportButton = document.createElement("button");
                            exportButton.id = "export-csv";
                            exportButton.style.marginRight = "10px";
                            exportButton.textContent = "Export as CSV";

                            exportButton.onclick = function () {

                                if (!window.tabulatorTable) {
                                    console.error('Tabulator instance not found!');
                                    return;
                                }


                                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                                const courseName = "{{ course_name }}".replace(/[^a-zA-Z0-9]/g, '_');

                                try {

                                    const table = window.tabulatorTable;

                                    // Get current data with all calculated values
                                    const currentData = table.getData();


                                    // Get visible columns
                                    const visibleColumns = table.getColumns()
                                        .filter(col => col.isVisible())
                                        .map(col => col.getField());


                                    // Prepare data for export
                                    const exportData = currentData.map(row => {
                                        const exportRow = {};
                                        visibleColumns.forEach(field => {
                                            if (field.endsWith('_collapsed')) {

                                                const groupName = field.replace('_collapsed', '');
                                                const groupCol = table.getColumn(field);
                                                if (groupCol) {
                                                    const cell = groupCol.getCells().find(c =>
                                                        c.getRow().getData().username === row.username
                                                    );
                                                    if (cell) {
                                                        exportRow[field] = parseInt(cell.getValue()) || 0;

                                                    }
                                                }
                                            } else if (field.startsWith('scores.')) {
                                                // Handle nested scores data

                                                const taskName = field.split('.')[1];
                                                const value = row.scores && row.scores[taskName] || 0;
                                                exportRow[field] = value;

                                            } else {
                                                exportRow[field] = row[field];
                                            }
                                        });

                                        return exportRow;
                                    });


                                    // Create CSV content
                                    const headers = visibleColumns;
                                    const csv = [
                                        headers.join(','),
                                        ...exportData.map(row =>
                                            headers.map(field =>
                                                JSON.stringify(row[field] || '')
                                            ).join(',')
                                        )
                                    ].join('\n');

                                    // Trigger download
                                    const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
                                    const link = document.createElement('a');
                                    if (link.download !== undefined) {
                                        const url = URL.createObjectURL(blob);
                                        link.setAttribute('href', url);
                                        link.setAttribute('download', `${courseName}_database_export_${timestamp}.csv`);
                                        link.style.visibility = 'hidden';
                                        document.body.appendChild(link);
                                        link.click();
                                        document.body.removeChild(link);
                                    }
                                } catch (error) {
                                    console.error('Error exporting CSV:', error);
                                }
                            };

                            footer.insertBefore(exportButton, footer.firstChild);
                        }
                    }, 100);
                    // Toggle personal info columns (admins only)
                    {% if is_course_admin %}
                    const toggleButton = document.getElementById('toggle-personal-info');
                    if (toggleButton) {
                        const personalColumns = ['first_name', 'last_name', 'comment'];

                        toggleButton.addEventListener('click', function() {
                            const firstCol = window.tabulatorTable.getColumn('first_name');
                            const isVisible = firstCol ? firstCol.isVisible() : false;
                            
                            personalColumns.forEach(field => {
                                const col = window.tabulatorTable.getColumn(field);
                                if (col) {
                                    if (isVisible) {
                                        col.hide();
                                    } else {
                                        col.show();
                                    }
                                }
                            });
                            
                            const icon = toggleButton.querySelector('i');
                            if (icon) {
                                if (isVisible) {
                                    icon.classList.remove('fa-eye');
                                    icon.classList.add('fa-eye-slash');
                                } else {
                                    icon.classList.remove('fa-eye-slash');
                                    icon.classList.add('fa-eye');
                                }
                            }
                            
                            window.tabulatorTable.redraw(true);
                        });
                    }
                    {% endif %}
                })
                .catch(error => {
                    console.error('Error creating table:', error);
                });
        });
    </script>
{% endblock %}
